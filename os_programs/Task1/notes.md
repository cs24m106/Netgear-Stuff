## IPC using Message Queues
Inter-Process Communication (IPC) is a method for communication within processes to exchange data, control information, or synchronizing tasks. There are various methods available for inter-process communication (IPC), like IPC using shared memory, message passing, semaphores, sockets, and message queues.

Reference: https://www.geeksforgeeks.org/operating-systems/ipc-using-message-queues/

Keypoints:
- linked list of messages stored within the kernel
- send and receive messages between processes in a first-in-first-out (FIFO) manner
- `msgget()`: create a new queue or open an existing queue
- `msgsnd()`: new messages are added to the end of a queue
- Note: every message has a positive long integer type field: corresponding to the non-negative length which are specified to  send call
- `msgrcv()`: messages are fetched from a queue
- Note: We don't have to fetch the messages in a first-in, first-out order. Instead, we can fetch messages based on their type field.
- need for msg_ques: enables asynchronous communication, where messages are placed in a queue and retrieved by processes in a convenient manner.

### Various System Calls fns
malloc (memory contains garbage/indeterminate values) vs 
calloc (memory is initialized to all bits zero, thus with slight overhead)
```c
ptr = (type*)malloc(size_in_bytes);
ptr = (type*)calloc(num_elements, size_of_element);
```

```c
PROTOTYPE: int msgctl ( int msgqid, int cmd, struct msqid_ds *buf );
RETURNS: 0 on success
        -1 on error : updates errno accordingly
COMMMANDS: IPC_STAT, IPC_SET, IPC_RMID
```
- IPC_RMID: Removes the queue from the kernel.
- The kernel maintains an instance of this structure for each queue which exists in the system. 
- By using the IPC_STAT command, we can retrieve a copy of this structure for examination.
- if errno: EINVAL  => msgqid invalid, or msgsz less than 0


```c
PROTOTYPE: int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
RETURNS: 0 on success
        -1 on error : updates errno -> EACCES, EAGAIN, EIDRM, EINTR, EINVAL

int msgp: points to a user-defined buffer that must contain first a field of type long int 
          that will specify the type of the message, and then a data portion 
          that will hold the data bytes of the message.

msgp (struct msgbuf*): A pointer to your message buffer, which must be defined as:
struct msgbuf {
    long mtype; // Message "ty"pe" (must be > 0)
    char mtext[n]; // Message data" (size n)
};

size_t msgsz: The number of bytes in mtext (the data part). Set to 0 if sending only the type (no text).
```
Upon successful completion, the following actions are taken with respect to the data structure associated with msqid,
- msg_qnum is incremented by 1.
- msg_lspid is set equal to the process ID of the calling process.
- msg_stime is set equal to the current time.

```c
PROTOTYPE: int msgget(key_t key, int msgflg);
RETURNS: int 'msqid' (non negative) which is the message queue identifier
         -1 on error : updates errno accordingly

key_t key:  A unique integer value (often generated by the ftok() function) that identifies the message queue.
            Using the special value IPC_PRIVATE guarantees the creation of a new, unique message queue.
int msgflg: An integer that specifies both the access permissions and "control flags" typically combined (using the bitwise OR operator |)
            (e.g., IPC_CREAT, IPC_EXCL) for the queue. 
```

- **Accessing an existing queue:** 
    - If IPC_CREAT is not specified, 
    - msgget() returns the identifier for an existing queue associated with the given key, 
    - provided the process has the necessary permissions.
- **Creating a new queue:** 
    - A new message queue is created if the key is IPC_PRIVATE, 
    - or if the key doesn't exist and IPC_CREAT is specified in msgflg.
- **Permissions:** 
    - The low-order 9 bits of msgflg define the permissions for the queue, 
    - similar to file permissions (e.g., 0666 for read/write access for user, group, and others).
- **IPC_EXCL:** (exclusive)
    - When used with IPC_CREAT (e.g., IPC_CREAT | IPC_EXCL), 
    - it forces msgget() to fail if a message queue with the specified key already exists. 
    - This prevents a process from unintentionally using an existing queue. 

#### Common Permission Combinations:
- `0600` or `(S_IRUSR | S_IWUSR)`: Owner has read and write access, no one else has any access.
- `0660` or `(S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP)`: Owner and group have read and write access; others have no access.
- `0666` or `(S_IRWXU | S_IRWXG | S_IRWXO without execute bits)`, or `(all read/write bits OR'd together)`: Everyone has read and write access. 

|Constant 	|Description	|Octal Value|
|---|---|---|
|S_IRUSR	|Read permission for the owner (user)	|0400|
|S_IWUSR	|Write permission for the owner (user)	|0200|
|S_IRGRP	|Read permission for the group	|0040|
|S_IWGRP	|Write permission for the group	|0020|
|S_IROTH	|Read permission for others	|0004|
|S_IWOTH	|Write permission for others	|0002|

```c
int kill(pid_t pid, int sig); 
    system call is used to send a signal to a process or process group. 
    (generally used for IPC not just for terminating processes)
return 0 or -1 (errno set resp)

pid_t pid: Specifies the target process or process group. 
int sig: Indicates the signal to be sent. ex: 
    - SIGTERM - graceful termination
    - SIGKILL - immediate termination
    - SIGSTOP - pause a process
```
|System Call 	|Target|
|---|---|
|kill(pid, SIGTERM)	|Only the specific process with that pid.|
|kill(0, SIGTERM)	|Every process in the current process group (Parent + all Children).|
|kill(-1, SIGTERM)	|All processes the user has permission to signal (excluding system processes).|

NOTE: By default, child processes created via fork() inherit the parent's Process Group ID (PGID). <br>
Therefore, `kill(0, ...)` acts as a broadcast to the entire group.

---

## Multi-Threading in C
- [POSIX Threads](https://www.geeksforgeeks.org/operating-systems/posix-threads-in-os/) --> pthreads
- use explicit compile options `gcc sourceFile.c -lpthread` if prog shows error. Syntax:
```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine)(void *), void *arg); 
return 0 or -1 (errno set resp)
```
**Parameters:**<br>
- `thread`: A pointer to a pthread_t variable. A successful call stores the ID of the newly created thread in this location. This ID is used to refer to the thread in other pthreads functions (like `pthread_join()` or `pthread_cancel()`).
- `attr`: A pointer to a pthread_attr_t structure that specifies thread attributes (e.g., stack size, scheduling policy, detach state). If NULL, default attributes are used (a common practice for most simple applications).
- `start_routine`: A pointer to the function that the new thread will execute. This function must accept a single void* argument and return a void*.
- `arg`: A single argument of type void* that is passed to the start_routine function. If multiple arguments are needed, a pointer to a struct containing all arguments can be passed instead. 

```c
int pthread_join(pthread_t thread, void **value_ptr);
// is a blocking function; the calling thread is suspended until the specified thread terminates.
// without thread calls like pthread_join() or pthread_detach() can lead to resource leaks (zombie threads).
```
**Parameters**<br>
- `thread`: The ID of the target thread that the calling thread should wait for. This is the pthread_t value obtained during the call to `pthread_create()`.
- `value_ptr`: A pointer to a void * variable. Upon the target thread's termination, the value it passed to `pthread_exit()` (or the return value of its starting routine) is stored in the location referenced by `value_ptr`. If you don't need the return value, you can pass NULL. 

---

## MISC

### Create Random test files

Linux users: Arbitrarily large text files can be generated on Linux with the following command:
```c
tr -dc "A-Za-z 0-9" < /dev/urandom | fold -w100|head -n 100000 > bigfile.txt
```
Reference: https://stackoverflow.com/questions/44492576/looking-for-large-text-files-for-testing-compression-in-all-sizes

### memcmp vs loop check
memcmp is often implemented in assembly to take advantage of a number of architecture-specific features, which can make it much faster than a simple loop in C. [reference](https://stackoverflow.com/questions/21106801/why-is-memcmp-so-much-faster-than-a-for-loop-check)

Standard library implementations of memcmp are often highly optimized using architecture-specific assembly code and SIMD instructions, allowing them to compare multiple bytes (e.g., 8, 16, or 64 bytes at a time) in a single CPU cycle, making it much faster than a simple C loop.

### `struct name { ... };` vs `typedef struct { ... } name;`
- `struct name { ... };` defines a tagged struct type accessible as struct name. It does not create an alias name (unless you add a separate typedef).
- `typedef struct { ... } name;` defines an anonymous struct and creates a typedef name that you can use as a type directly (no struct keyword needed). Because the struct is anonymous, you cannot forward-declare it.
- `typedef struct name { ... } name;` combines both: it defines a tagged struct struct name and a typedef name that aliases struct name. This is common in C to allow both struct name and name.